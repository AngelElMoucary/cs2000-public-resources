---
sidebar_position: 10
hide_table_of_contents: true
title: Recitation 10 — Intro to Python
---

## Skills: [8](</skills/#(8)>)

## Introduction to Python

We've learned the basics in Pyret—expressions, functions, and data. Today, we will transition to Python, which uses different notation but similar concepts.

## Function Definitions and Types

### Basic Function Translation

**Pyret Version:**

```pyret
fun celsius-to-fahrenheit(temp :: Number) -> Number:
  doc: "convert Celsius temperature to Fahrenheit"
  (temp * 9/5) + 32
end
```

**Python Version:**

```python
def celsius_to_fahrenheit(temp: float) -> float:
    """convert Celsius temperature to Fahrenheit"""
    return (temp * 9/5) + 32
```

**Key Differences:**

- `def` vs `fun`
- Underscores vs hyphens in names
- Colons for type annotations
- Explicit `return` statement required
- Triple quotes for documentation
- Indentation instead of `end`

What happens if you forget the `return` statement in Python?

### Practice

Convert this Pyret function to Python:

```pyret
fun calculate-tip(bill :: Number, percentage :: Number) -> Number:
    doc: "calculate tip amount for a restaurant bill"
    bill * (percentage / 100)
end
```

## Conditionals in Python

### If-Else Translation

**Pyret Version:**

```pyret
fun letter-grade(score :: Number) -> String:
    doc: "convert numeric score to letter grade"
    if score >= 90:
        "A"
    else if score >= 80:
        "B"
    else if score >= 70:
        "C"
    else if score >= 60:
        "D"
    else:
        "F"
    end
end
```

**Python Version:**

```python
def letter_grade(score: float) -> str:
    """convert numeric score to letter grade"""
    if score >= 90:
        return "A"
    elif score >= 80:
        return "B"
    elif score >= 70:
        return "C"
    elif score >= 60:
        return "D"
    else:
        return "F"
```

**Key Differences:**

- `elif` instead of `else if`
- Each branch needs its own `return`
- Indentation determines code blocks

### Practice

Write a Python function for shipping cost:

- Orders under $25: $5 shipping
- Orders $25-$75: $3 shipping
- Orders over $75: free shipping

## Python Lists vs Pyret Lists

### Creating and Basic Operations

**Pyret vs Python Comparison:**

**Pyret:**

```pyret
my-list = [list: "red", "green", "blue", "yellow"]
first-color = my-list.first
rest-colors = my-list.rest
list-size = my-list.length()
```

**Python:**

```python
my_list = ["red", "green", "blue", "yellow"]
first_color = my_list[0]
rest_colors = my_list[1:]
list_size = len(my_list)
```

Point out indexing differences (0-based vs first/rest) and built-in `len()` function.

### Filter and Map Operations

**Pyret Version:**

```pyret
import lists as L

numbers = [list: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = L.filter(lam(n): num-modulo(n, 2) == 0 end, numbers)
squares = L.map(lam(n): n * n end, numbers)
```

**Python Version:**

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
evens = list(filter(lambda n: n % 2 == 0, numbers))
squares = list(map(lambda n: n * n, numbers))
```

**Key Differences:**

- Square brackets vs `[list: ...]`
- `lambda` instead of `lam`
- Must wrap `filter` and `map` with `list()` in Python

## Testing in Python

### Pyret where vs Python pytest

**Pyret Testing:**

```pyret
fun double(n :: Number) -> Number:
    doc: "double the input number"
    n * 2
where:
    double(5) is 10
    double(0) is 0
    double(-3) is -6
end
```

**Python Testing:**

```python
import pytest

def double(n: float) -> float:
    """double the input number"""
    return n * 2

def test_double():
    assert double(5) == 10
    assert double(0) == 0
    assert double(-3) == -6
    
# For floating-point comparisons:
def test_double_approx():
    assert double(3.3) == pytest.approx(6.6)
```

Need to run the file with pytest; running with python alone won't run tests.

**Key Differences:**

- Separate test functions instead of `where` blocks
- `assert` statements for testing

### Practice

Write tests for your shipping cost function.

## For Loops and List Processing

**Pyret (for each):**

```pyret
fun sum-numbers(numbers :: List<Number>) -> Number:
    doc: "sum all numbers in a list"
    var total = 0
    for each(n from numbers):
        total := total + n
    end
    total
end
```

**Python:**

```python
def sum_numbers(numbers: list) -> float:
    """sum all numbers in a list"""
    total = 0
    for n in numbers:
        total = total + n
    return total
```

**Key Differences:**

- No `var` keyword needed
- Regular assignment `=` instead of `:=`
- Simpler `for` loop syntax

## Wrap-Up

- What are the main syntax differences between Pyret and Python?
- When might you choose one language over the other?
