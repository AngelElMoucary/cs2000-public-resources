---
sidebar_position: 5
day_number: 5
title: Day 5 - Conditionals, Tests, and spy
---


TODO: add `spy`, maybe `ask`?

### This fully introduces function design recipe -- type annotation, doc string, tests, _then_ code.

## Outcomes: [1.1](/outcomes/#(1.1)),  [2.1](/outcomes/#(2.1)), [3.1](/outcomes/#(3.1))


## Decisions and Booleans

### **Day Objectives**
- Understand why and how to use conditionals (if expressions) in programs.
- Learn about booleans and how to combine them with operators like **and**, **or**, and **not**.
- Practice writing functions that use conditionals and combine functions together.
- Learn how to write function examples using `where`

---

### **I. Introduction and Motivation (5 minutes)**
- **Context:**
  Many problems require making _choices_ and doing different things depending on the result of particular questions.
  
  For example, we might look at the weather, and if it was sunny, choose to wear a sun-hat, but if it was colder, do something different.
  
---

### **II. Example: Choosing Headwear (10 minutes)**
#### **A. Scenario Description**
- **Example Scenario:**
  You look at the weather, and if the temperature is:
  - Above 80F/27C you wear a "sun hat"
  - Above 50F/10C but below 80F/27C you wear "no hat"
  - Below 50F/10C you wear a "winter hat"

#### **B. Exploring Examples (Do Now)**
- Ask students:
  - "What hat would you expect if the temperature was 80F? What about 80.01F, 50F, and 35F?"
  Encourage them to identify the boundary values.

- Let's write down some examples of a function we will define later:
  - `choose-hat(80) is "no hat"`
  - `choose-hat(80.01) is "sun hat"`
  - `choose-hat(50) is "winter hat"`
  - `choose-hat(35) is "winter hat"`

### **III. Introduction to Booleans (10 minutes)**
#### **A. What Are Booleans?**
- **Definition:**
  Booleans are the values `true` and `false`. They result from comparisons and logical tests.

- **Simple Examples (Do Now):**
  - Ask students to type:
    ```pyret
    1 < 2    # Should produce true
    5 == 5   # Should produce true
    5 == 4   # Should produce false
    ```

#### **B. Other Boolean Operations**
- **Comparisons and Equality:**
  Explain that in addition to `<` and `==`, we also have operators like `>=` or type-specific ones (e.g., `string-equal`).
- **Combining Booleans:**
  Introduce:
  - **and:** `(1 < 2) and (3 < 4)` yields `true`
  - **or:** `(1 < 2) or (5 < 3)` yields `true`
  - **not:** `not(1 < 2)` yields `false`

- **Interactive Exercise:**
  Ask:
  - "What do you think `(2 < 1) or (4 == 4)` evaluates to?"
  - "How about `not(2 < 1)`?"

- **Discussion:**
  Emphasize that booleans let us express yes/no, true/false decisions, which are the heart of conditionals.

---

#### **IV. Writing a Basic Function with a Conditional**
- **Explain the if-expression syntax:**
  - An if-expression asks questions that produce booleans and then chooses
    corresponding answers. With more than two options, the middle are captured
    by `else if`. These questions are run in order, and the answer that
    corresponds to the first `true` is returned.

- **Write the Function (code shown on screen):**
  ```pyret
  fun choose-hat(temp-in-F :: Number) -> String:
    doc: "Choose hat to wear based on temp fahrenheit: "sun hat" if > 80, "no hat" if <= 80 and > 50, "winter hat" if < 50."
    if temp-in-F > 80:
      "sun hat"
    else if temp-in-F > 50:
      "no hat"
    else:
      "winter hat"
    end
  end
  ```

- **Doc strings**: This introduces a new feature of functions: documentation
  strings! All functions should have concise descriptions of how they work. For
  very simple functions, these may be similar to the function implementation,
  but as functions become more complex, these doc strings are invaluable for
  understanding how to **use** the code, rather than how it **works**.

- **Live Demo:**
  - Run the function and then test:
    ```arr
    choose-hat(80) # "no hat"
    choose-hat(80.01) # "sun hat"
    choose-hat(50) # "winter hat"
    choose-hat(35) # "winter hat"
    ```
- **Discussion:**
  Point out how the if-expression checks conditions in order and returns the first true branch.

- **Testing**
  - Running tests by hand in the interactions window is slow, and likely to be
    ineffective, since you are unlikely to rerun every test every time you make
    a change. It is much better to capture the tests in the actual code, which
    you can do with a `where` clause for functions:

  ```pyret
  fun choose-hat(temp-in-F :: Number) -> String:
    doc: "Choose hat to wear based on temp fahrenheit: "sun hat" if > 80, "no hat" if <= 80 and > 50, "winter hat" if < 50."
    if temp-in-F > 80:
      "sun hat"
    else if temp-in-F > 50:
      "no hat"
    else:
      "winter hat"
    end
  where:
    choose-hat(80) is "no hat"
    choose-hat(80.01) is "sun hat"
    choose-hat(50) is "winter hat"
    choose-hat(35) is "winter hat"
  end
  ```
  
  Now, every time you hit Run, all tests will be run, and any failures will be
  reported. 

  


### **V. Stepping Back, Design (10 minutes)**
- **Motivation**
  Describe full function design recipe.
  
- While we added the `where` block after we wrote the function, we came up with
  the examples first, when we were trying to figure out how the function should
  work. This suggests there is an **order** we should carry out writing new
  functions, and we can make this concrete as a Design Recipe for functions:
  
  1. Type Annotation - Once we have decided we need to write a function, the
     first thing we should think about, assuming we were not told it, is what
     type of inputs the function should take and what type of output it should
     produce. While we introduced type annotations as a way to get better error
     messages, and indeed they are, this use as part of a design process is
     indeed much more important: it helps us organize our thoughts! 
     
  2. Doc String - After figuring out the types of data the function operates
     over, it is worth writing down what the function should do! This is in
     English, and it doesn't need to include how the function works (and usually
     shouldn't) -- the purpose of the explanation is so that someone can
     understand how to **use** the function, not how it works internally. While
     this serves as useful documentation, it is even more useful as part of a
     design process, since like type annotations, it helps us organize our
     thoughts -- in particular, it makes us think a little bit more concretely about
     how the code should work -- i.e., how is the output constructed from the input.
     
  3. Tests -- The third step is writing tests is a `where` block -- these examples 
     serve as the most concrete step of our design process, as its the point where we
     think through concrete cases of inputs, and exactly the output they should produce. 
     It may be, as we write them, that we realize we did not think of something in the 
     earlier steps, which is fine -- we go back and fix those and then continue forward.
     In addition to forming a useful step in the design process, these tests will also
     be used to check that our function works as expected!
     
  4. Code -- The last step, which we should only do **after** the first three, is writing
     down the code. There is a strong tendency for students, especially beginners, to want
     to jump ahead -- but the clarity that comes from doing the earlier steps will make 
     writing the code easier, to the point that it is faster to not skip ahead. 

#### **B. Design Recipe Practice: Determining Driving Eligibility (15 mins)**
- **Scenario:** 

  Let's practice this on a new scenario -- a function that
  determines if a person can drive. Let's say the rules are: a person can drive
  if they are **16 or older** and they **have a license**.

- **Type Annotation** First, we figure out the type annotations, and also argument and function names. These
  collectively form the function "header":
  ```pyret
  fun can-drive(age :: Number, has-license :: Boolean) -> Boolean:
  ```

- **Doc String** Next, we write a doc string, capturing what the function should do. In cases like 
   this, where we have been specifically tasked to write a single small function, 
   the doc string will look a lot like the prompt -- this is fine; as programs get bigger,
   and some functions arise from your own problem solving, not from assignment prompts,
   this artificial aspect will disappear:
   
   ```pyret
     doc: "Return true if age is at least 16 and the person has a driver's license."
   ```
   
- **Tests** Third, we write examples in a where block. This will be at the end of the body, so we can 
   just leave the body itself blank for now.
  ```pyret
  where:
    can-drive(15, true) is false
    can-drive(16, false) is false
    can-drive(18, true)  is true
  end
  ```

- **Code** And finally, we fill in code to make our tests pass:
  ```pyret
    age >= 16 and has-license
  ```

- Now, we can hit run and see if our code passes our tests. If not, we can work on fixing
  our code to match how we wanted it to work.

- **Discussion:** While `and` combined these two booleans together, do we
  actually need both of these tests?
  

---

### **VI. Evaluating Expressions by Reduction (5 minutes)**
- **Walk Through a Step-by-Step Reduction:**
  Use `choose-hat(35)` as an example.
  - Start with:
    ```pyret
    if 35 > 80:
      "sun hat"
    else if 35 > 50:
      "no hat"
    else:
      "winter hat"
    end
    ```
  - Explain that since `35 > 80` is false, we check the next condition.
  - Since `35 > 50` is also false, we move to the else branch, yielding `"winter hat"`.

- **Discussion:**
  Emphasize that understanding these steps can help debug programs.

---

### **VII. Composing Functions (5 minutes)**
#### **A. Combining Functions in a Computation**
- **Scenario:**
  Now imagine you got new sunglasses, and want to have the string you return always add ", and glasses" to what you will wear.
  
- **Designate `add-glasses` Function:**
  ```pyret
  fun add-glasses(outfit :: String) -> String:
    doc: "Adds ', and glasses' to input."
    outfit + ", and glasses"
  where:
    add-glasses("coat") is "coat, and glasses"
  end
  ```
- **Compose the Functions:**
  - Write an expression that determines the final outfit:
    ```pyret
    add-glasses(choose-hat(75))
    ```

#### **B. Discussing Evaluation:**
- Compare two styles:
  - One that names the intermediate result:
    ```pyret
    output = choose-hat(75)
    add-glasses(outfit)
    ```
  - And one that nests the calls.
- Ask: "Which style do you find clearer and why?"

---

### **VIII. Local Variables (5 minutes)**
#### **A. Scenario: Add an optional visor**
- **New Rule:**
  Some people have a visor that they wear when the temperature goes above 95F/35C!

- **Design the function:**

- **Type Annotation**
  ```pyret
  fun choose-hat-visor(temp-in-F :: Number, has-visor :: Boolean) -> String:
  ```
  
- **Doc String**
  ```pyret
    doc: "Choose hat and, if has-visor, use a visor at temps above 95F/35C."
  ```

- **Tests**
  ```pyret
  where:
    choose-hat(80) is "no hat"
    choose-hat(80.01) is "sun hat"
    choose-hat(50) is "winter hat"
    choose-hat(35) is "winter hat"
    choose-hat(90,true) is "no hat"
    choose-hat(91,true) is "visor"
    choose-hat(91,false) is "no hat"
  end
  ```
  
- **Code**
  ```pyret
    base = choose-hat(temp-in-F)
    if has-visor and (temp-in-F > 90):
      "visor"
    else:
      base
    end
  ```
- **Discussion:**
  Explain that the local variable `base` is defined only inside the function. Emphasize that names defined within a function (like `base`) are not accessible outside.

---

### **VIII. Recap and Q&A (5 minutes)**
- **Key Points Recap:**
  - **Conditionals:**
    How `if`, `else if`, and `else` let your program decide between different outcomes.
  - **Booleans:**
    Exactly two values `true` and `false` and how to combine them using **and**, **or**, and **not**.
  - **Design Recipe**
    Step by step process for constructing functions
  - **Function Composition:**
    Combining functions and the role of local variables in a program directory.
