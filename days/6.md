---
sidebar_position: 6
day_number: 6
title: Day 6 - Introduction to tables
---

Note: this seems short -- fill out

## [Outcomes](../outcomes/): 5


## Pre-reading: [4.1.1](https://dcic-world.org/2024-09-03/intro-tabular-data.html#%28part._.Creating_.Tabular_.Data%29) \& [4.1.2](https://dcic-world.org/2024-09-03/intro-tabular-data.html#%28part._.Extracting_.Rows_and_.Cell_.Values%29)

## Intro (15 min)

**Goal** Learn about tabular data, creating tables literally, importing data, extracting rows and cell values.

- Many everyday pieces of data -- like a workout journal, recipe index, or
  library catalog — are naturally represented as **tables**, a type of data
  where there are many **rows** where each row has the same set of attributes,
  called **columns**.
- Tables are values, just like numbers, strings, images, and booleans, and small ones can be directly typed into Pyret as:
  ```pyret
  workouts = table: date :: String, activity :: String, duration :: Number
    row: "2025-04-01", "Running", 30
    row: "2025-04-02", "Yoga", 45
    row: "2025-04-03", "Cycling", 60
  end
  ```
- Note that after the `table:` comes a list of columns, with optional type
  annotations. This is then followed by a sequence of rows, that each must have
  exactly the columns mentioned at the beginning.
- Since tables are values, they can be the input and output of functions, and
  can be used in examples. An important detail: when comparing tables for
  equality (like in test cases) the order of rows matters! 
- We can use `check: ... end` to write a set of tests not associated with a function, and use that to see: 
  ```pyret
  check:
    table: date :: String, activity :: String, duration :: Number
      row: "2025-04-01", "Running", 30
      row: "2025-04-02", "Yoga", 45
      row: "2025-04-03", "Cycling", 60
    end
    is-not
    table: date :: String, activity :: String, duration :: Number
      row: "2025-04-03", "Cycling", 60
      row: "2025-04-01", "Running", 30
      row: "2025-04-02", "Yoga", 45
    end
  end
  ```

**B. Importing from External Sources**

```pyret
import csv as CSV
# OR include csv
recipes = load-table:
  title :: String,
  servings :: Number,
  prep-time :: Number
  source: CSV.csv-table-file("recipes.csv", CSV.default-options)
end
```

Data from spreadsheets or CSVs load seamlessly into Pyret via `load-table`.

---

**III. Extracting Rows and Cell Values (15 minutes)**

**A. Row-by-Index**

A table is a collection of Row values. When Pyret displays a Row value, it shows you the column names and the corresponding values within the row.
Note: Pyret numbers rows from 0 (the first row) to n–1 (the last). 

```pyret
second-workout = workouts.row-n(1)
# -> Row: date = "2025-04-02", activity = "Yoga", duration = 45
```
In the example above, `workouts.row-n(1)` dig into the workouts table and extracts the row at index 1. Remember that since rows are zero-indexed, this means that it will extract the second row in the table.

**Live Demo:**
- Enter workouts in the interactions pane and note its value
- Enter workouts.row-n(1) to see the row object
- Ask students: what happens if you try workouts.row-n(3) when only three rows exist?

**B. Accessing Cells**

Often you only need a single piece of information — say, the duration of a workout — rather than the entire row. We can use `row["column-name"]` to extract a single cell. In the example of workouts table, if we'd like to access "Yoga" or 45, we can do so through the code below:

```pyret
second-workout["activity"]  # -> "Yoga"
# or inline:
workouts.row-n(1)["duration"]  # -> 45
```

* **Do Now:** What happens if you write `workouts.row-n(1)[duration]` (without quotes)?


