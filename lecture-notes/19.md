---
sidebar_position: 19
lecture_number: 19
title: Lecture 19 - Conditional data
---

## Introduction to Conditional Data

### 1. Introduction (10 minutes)

- **Overview:**
  - Explain that sometimes data can come in multiple forms and that we need a way to represent alternatives within one type.
  - Introduce the idea of conditional data—data that can be one of several variants.

- **Example Context:**
  - A payment system where a payment can be made by cash, credit card, or check.

- **Learning Goals:**
  - Understand what conditional data is.
  - Learn how to define and create conditional data types in Pyret.
  - Use pattern matching with `cases` to distinguish among variants.

- **Do Now:**
  - Ask: “Can you think of a situation where one type of data might have several different forms? (Examples: transportation mode, notification type, or feedback type)”
  - Briefly share responses.

---

### 2. Defining and Creating Conditional Data (20 minutes)

- **Defining a Conditional Data Type:**
  - Define a new type called `PaymentMethod` with three variants:
    - `cash` (no extra data)
    - `credit` (with card-number and expiry)
    - `check` (with bank-account and check-number)
  - **Pyret Code:**
    ```pyret
    # Define a PaymentMethod type with multiple variants
    data PaymentMethod:
      | cash
      | credit(card-number :: String, expiry :: String)
      | check(bank-account :: String, check-number :: Number)
    end
    ```

- **Creating Examples:**
  - Create instances of `PaymentMethod`.
  - **Examples:**
    ```pyret
    # Create different payment methods
    payment-1 = cash
    payment-2 = credit("1111-2222-3333-4444", "09/26")
    payment-3 = check("987654321", 55)
    ```

- **Annotations:**
  - Emphasize that the variables should be annotated with `PaymentMethod` (e.g., `payment-2 :: PaymentMethod`).

- **Interactive Exercise:**
  - Ask: “How would you annotate `payment-2`? What error might you see if the annotation is wrong?”

---

### 3. Programming with Conditional Data (20 minutes)

- **Telling Apart Variants with `cases`:**
  - Write a function that returns a descriptive string for a payment method.
  - **Example Function:**
    ```pyret
    fun display-payment(p :: PaymentMethod) -> String:
      cases (PaymentMethod) p:
        | cash => "Paid in cash"
        | credit(cn, exp) => "Paid by credit card ending in " + string-from-number(string-length(cn)) + " digits; expires " + exp
        | check(acc, num) => "Paid by check from account " + acc + " (check #" + string-from-number(num) + ")"
      end
    end
    ```
  - **Note:** In the `credit` branch, we use `string-length` merely to demonstrate field access (in practice, one might extract the last four digits).

- **Interactive Exercise:**
  - Ask: “What is the output of `display-payment(payment-3)`?”
  - Expected output:
    `"Paid by check from account 987654321 (check #55)"`
  - Then ask: “What does `display-payment(cash)` return?”

- **Processing Fields in Variants:**
  - Explain that in each `cases` branch, fields are automatically bound to the names given (e.g., `cn` and `exp` in `credit`).

- **Group Discussion:**
  - How does pattern matching with `cases` help manage data with multiple shapes?

---

### 4. Wrap-Up and Reflection (10 minutes)

- **Recap Key Points:**
  - Conditional data allows us to represent values that can be one of several forms.
  - We define these types using `data` with multiple alternatives (each introduced with a `|`).
  - Pattern matching with `cases` distinguishes the different variants and binds their fields.

- **Exit Ticket:**
  - Each student writes a short explanation (2–3 sentences) about the difference between structured and conditional data and why conditional data require pattern matching.

- **Homework Prompt:**
  - Create your own conditional data type (for example, a transportation mode with variants such as `bus`, `train(carriages :: Number)`, and `bicycle`) and write a function that returns a brief description.
