---
sidebar_position: 2
hide_table_of_contents: true
title: Lab 2 -- String Encryptors
---

## Purpose

Learn how to define functions, and about string library

TODO: Rewrite the below; while Brown has given us permission to use assignments,
we shouldn't plagiarize!

------

You're on a top secret mission and need to communicate an encrypted message containing important code. However, the instructions to your encryption machine were accidentally thrown into a hay bale, and now it’s up to you to figure out how the machine works!

The encryptor machine has 10 black-box functions that encrypt a String. Your first task is to test various inputs and figure out how each function changes the input based on the output.

Once you have an idea of what an encryption function does, write a version of the function that encrypts a String in the same manner and run it through the checks in the support file. If all checks pass, then you’ve successfully built an encryptor for covert communications!

Hint: The encryptors are composed of functions from the Pyret Strings library. Start by reading through it.

Here is an example of what an encryptor looks like under the hood:

```
provide *
provide-types * 

fun encryptor0(s :: String) -> String:
  doc: "returns the first letter of the string" 
  string-substring(s, 0, 1)
end

check "encryptor0: empty str":
  encryptor0("") raises "index"
end

check "encryptor0: general":
  encryptor0("a") is "a"
  encryptor0(" ") is " "
  encryptor0("hello") is "h"
  encryptor0("1, ") is "1"
end
```

We created an encryptor called encryptor0 that takes in a string and returns the first letter only. We use check blocks to ensure that it works correctly given empty and non-empty strings.

### Instructions

Include this at the top of your program (before any other code, including code from the previous parts):

TODO: This will work differently; will be a compiled JS file (effectively obfuscated) in a Github project.
```
import shared-gdrive("lab1-support-2022.arr", "1kS_-rd0eE9-DLndIYw-0Bez8c6J73MRK") as support
```

Now you will be able to access all of the encryptors and their testers in your Pyret file.

The encryptor functions are named

```
support.encryptor1,
support.encryptor2,
support.encryptor3,
...
support.encryptor10
```

The encryptor functions take in Strings as input (e.g: `support.encryptor1("mystery")`) and produce an encrypted result.

Please keep a record of what Strings you use to test each encryptor – you should be prepared to explain your choice of Strings to a TA. They will be useful for you to reference, too!

The tester functions are named:

```
support.test-encryptor1,
support.test-encryptor2,
support.test-encryptor3,
...
support.test-encryptor10
```

To use them, you must use the name of your function as an input. For example, after giving some inputs to `support.encryptor1`, you may think it always returns the String `"cs2000"` (HINT: it doesn't do this – just an example). Then you would write the function:

```
fun my-cool-encryptor(str :: String) -> String:
    "cs2000"
end
```

You would test whether your function is correct (meaning it does the same thing as encryptor1 for all inputs) by running:

```
support.test-encryptor1(my-cool-encryptor)
```

Hint: The Pyret Strings library will be very helpful when writing your functions!

More Hints!

- When choosing Strings to use as inputs to the encryptors, it will be useful to vary your inputs – think about why this could be. In what ways can you vary your Strings?
- Think about scenarios where we might see strings of text, such as a book or report. What symbols might you commonly see in that text, other than alphabetical letters?
- Remember that Strings in Pyret are 0-indexed. This means that the first character in a string will be assigned index 0 (not 1).
- Encryptor 9 is one of the trickiest. Try strings of various lengths that start with the same letters. What do you notice?
